<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>Streaming | Hkube</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="Hkube: HPC over Kubernetes."/><meta property="og:description" content="Hkube - HPC over Kubernetes, cloud native open source framework to run distributed pipeline of algorithms"/><meta property="og:type" content="website"/><meta property="og:url" content="http://hkube.org/"/><meta property="og:image" content="/img/home/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@hkube"/><meta name="twitter:title" content="Hkube: HPC over Kubernetes"/><meta name="twitter:description" content="Hkube HPC over Kubernetes"/><meta name="twitter:image" content="/img/home/twitter_image.png"/><link rel="shortcut icon" href="/img/home/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="Hkube Team Blog"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"/></head><body><header class="nav-header "><section class="nav-section"><input type="checkbox" id="toggle-menu-checkbox" checked=""/><label id="toggle-menu" for="toggle-menu-checkbox" class=""><span id="toggle-menu-icon"></span></label><a class="nav-home" href="/"><img class="nav-logo" src="/img/home/top-logo.svg"/></a><nav id="nav-links"><a href="/learn/">Get Started</a><a href="/tech/">Tech</a><a href="/media/">Media</a><a href="/blog/">Blog</a><a href="https://playground.hkube.org/" target="_blank" rel="noopener noreferrer">Playground</a><a href="https://github.com/kube-HPC" target="_blank" rel="noopener noreferrer">GitHub</a><a href="/spec/" target="_blank">Spec</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="Search docs..."/></div></section></header><section class="column"><div class="documentationContent"><div class="inner-content"><h1>Streaming</h1><div><h2 id="introduction">Introduction<a class="hash-link" href="#introduction">#</a></h2><p>While Batch processing is need for some cases, such as gathering and data enrichment, there are other cases where the data is generated continuously, which typically send in the data records simultaneously. Streaming data includes a wide variety of data such as log files generated by customers using your mobile or web applications, eCommerce purchases, in-game player activity, information from social networks, financial trading floors, or geospatial services telemetry from connected devices or instrumentation in data centers.<br/>HKube&#x27;s data streaming is an extension to HKube batch processing pipeline architecture that handles millions of events at scale,
In real-time. As a result, you can collect, analyze, and store large amounts of information.
That capability allows for applications, analytics, and reporting in real-time.</p><p><img src="../../img/streaming/Streaming-diagram-nobackground.png" alt="StreamingDiagram"/></p><h3 id="use-cases-stream-tweets-in-real-time">Use Cases - Stream Tweets in real-time<a class="hash-link" href="#use-cases-stream-tweets-in-real-time">#</a></h3><p>So what are HKube data streams good for? Let&#x27;s take a look at a stream from Twitter as an example. In this particular case, we want to enrich the data from other resources, such as Facebook, LinkedIn, and other internal databases before saving it.
The process is as follows:</p><ul><li>Stream Tweets in Real-Time: Use the Twitter API and HKube Streaming to get and analyze real-time tweets for your research.</li><li>twitt node: The &quot;twitt&quot; node subscribes to the Twitter API and receives real-time tweets.</li><li>sort node: The &quot;sort&quot; node sorts the tweets based on their language and routes them accordingly.</li><li>Nodes &quot;A&quot; and &quot;B&quot; analyze the tweet messages and save them to the database.</li></ul><h3 id="creating-a-pipeline-stream">Creating a Pipeline Stream<a class="hash-link" href="#creating-a-pipeline-stream">#</a></h3><p>To create a stream, you will have to create a new pipeline.
To make life easier, HKube offers an easy wizard to create a pipeline. There is also an option to enter json file text editor.
In the wizard, you have 3 steps:</p><ul><li>Initial: Here you must set a name, and select the Pipeline Kind to be Streaming.</li><li>Nodes: Here you set your nodes kind (stateless, stateful, gateway), names and their algorithms. Algorithms must be pre-uploaded to HKube <a href="../#getting-started" target="_blank" rel="nofollow noopener noreferrer">(how to upload)</a>.</li><li>Options: Here you can set your Streaming Flows. First, you need to give it a name. Afterward enter the syntax manually or by using the wizard. More information about how stream flow syntax works will be explained in detail <a href="#streaming-flow">later</a>. Additionally, you must select a default flow, which will be used when no flow name is stated while invoking the sendMessage method, unless we are running from a node that is already a part of a flow.</li></ul><p><img src="../../img/streaming/CreatingStreamingPipeline.gif" alt="PipelineWizard"/></p><h2 id="features">Features<a class="hash-link" href="#features">#</a></h2><p>HKube streaming pipeline uses Stateful and Stateless algorithms, and supports:</p><h3 id="unique-data-transportation">Unique data transportation<a class="hash-link" href="#unique-data-transportation">#</a></h3><p>HKube has its own data transportation system, enabling direct data transfer between nodes in a manner that ensures the following</p><ul><li>The data will maintain its order.</li><li>High throughput with low latency.</li><li>High scalability.</li></ul><hr/><h3 id="autoscaling">Autoscaling<a class="hash-link" href="#autoscaling">#</a></h3><p>The throughput of streaming can vary over time, allowing us to handle bursts and free up resources for other jobs when they are not needed.
With its own unique heuristic system, HKube is able to recognize changes in throughput and act quickly to support these needs.
To better understand this, let&#x27;s look at a scenario that demonstrates how HKube handles pressure.</p><h4 id="scaling-range">Scaling Range<a class="hash-link" href="#scaling-range">#</a></h4><p>Autoscaling is used by each node by adjusting the number of pods it uses within the specified min-max range.
By using autoscaling, we shut down unnecessary pods to maintain efficiency.
HKube allows to adjust the minimum and maximum number of pods for stateless node:</p><p><strong>Minimum:</strong></p><ul><li>Defines the minimum number of pods for a stateless node.</li><li>The number of running pods can&#x27;t be lower than the pre-defined minimum.</li><li>When the application starts, the stateless node will initialize at application up-time, which may be more time-efficient.</li><li>This setting it essential when the resource is needed at up-time.</li></ul><p><strong>Maximum:</strong></p><ul><li>Defines the maximum number of pods for a stateless node.</li><li>The number of running pods can&#x27;t be higher than the pre-defined maximum.</li><li>It can be toggled off, in which case the system has no maximum limit.</li><li>This setting is essential when it&#x27;s necessary to limit the given resources.</li></ul><hr/><h3 id="edge-statistics">Edge Statistics<a class="hash-link" href="#edge-statistics">#</a></h3><p>HKube shows detailed statistics on the flow between a pair of nodes, which can be used to analyze the relationships between them.
To view the statistics, place your cursor over the flow between the nodes.
By using the statistics, you can obtain data about the requests and responses, as follows:</p><ul><li><strong>Messages produce rate:</strong> The rate at which messages arrive in the queue, calculated as (Δ message count) / (Δ time in seconds).</li><li><strong>Messages in queue:</strong> The number of messages currently waiting to be handled.</li><li><strong>Avg number of messages in queue:</strong> The average number of messages in the queue.</li><li><strong>Time messages spent in queue:</strong> The average time (in ms) messages spend waiting in the queue.</li><li><strong>Handle acknowledge received after:</strong> The average round trip time (in ms) for message handling, measured from when a message is pulled until confirmation is received from the next node.</li><li><strong>Total sent:</strong> The total number of messages pulled for handling by the next node.</li><li><strong>Total handle aknowledge:</strong> Total messages which has been handled.</li><li><strong>Dropped messages:</strong> The total number of messages that had to be dropped due to breaching the queue size limit.</li><li><strong>Throughput:</strong> Displayed on the arrow between the nodes. Request rate / response rate as a percentage. For example, if you see 33%, it means the ratio between requests and responses is 3 to 1.</li></ul><p>The following are statistics that are relevant to the recieving node:</p><ul><li><strong>Messages process rate:</strong> The rate of messages leaving the queue, calculated as (Δ message count) / (Δ time in seconds).</li><li><strong>Message process time:</strong> Time in ms that the pod is processing the message, time spent in the onMessage() method in your code.</li></ul><p>The following are statistics that are relevant to a stateless node:</p><ul><li><strong>Number of instances:</strong> The number of pod instances that are running the algorithm and processing the messages.</li><li><strong>Needed instances:</strong> The required amount needed to handle the queue and produce rate.</li></ul><p><img src="../../img/streaming/Statistics.png" alt="Statistics"/></p><hr/><h3 id="conditional-data-flows">Conditional Data Flows:<a class="hash-link" href="#conditional-data-flows">#</a></h3><p>In streaming data, most of the time, we expect the data to follow a specific flow. However, there are scenarios where we need to dynamically change this flow. To illustrate, let&#x27;s consider the Twitter use case: typically, we aim to enrich the data with additional information from other resources. However, there may be instances where we are unable to identify the author of a post. In such cases, we need to establish additional prerequisites before proceeding with the enrichment. HKube assists in handling such situations with conditional data flow. We will explain how to create and work with this feature later.</p><hr/><h3 id="how-to-work-with-streaming-pipelines">How to Work with Streaming Pipelines<a class="hash-link" href="#how-to-work-with-streaming-pipelines">#</a></h3><p>Streaming pipelines are built from Stateful and Stateless algorithms.</p><h4 id="stateful-algorithm">Stateful Algorithm:<a class="hash-link" href="#stateful-algorithm">#</a></h4><ul><li>A stateful algorithm is tailored for a specific execution.</li><li>The stateful algorithm must use HKube&#x27;s SDK to decide on which flow the data should continue: the default one or one of the conditionals.</li><li>Only one stateful algorithm can be executed for each algorithm kind in a specific execution.</li><li>There can be multiple stateful algorithms with different node names.</li><li>The stateful algorithm will be closed if one of the following occurs:<ul><li>The execution is terminated by the client using HKube&#x27;s API.</li><li>The main function of the algorithm returns.</li></ul></li></ul><h4 id="stateless-algorithm">Stateless Algorithm:<a class="hash-link" href="#stateless-algorithm">#</a></h4><ul><li>A stateless algorithm can serve multiple executions throughout its life.</li><li>The stateless algorithm can dynamically scale (up/down) according to the job’s needs.</li><li>Upon failure, HKube will skip the current execution for performance reasons.</li><li>The stateless algorithm doesn&#x27;t need to use HKube&#x27;s API to continue the flow; this happens after the return command.</li><li>Scaling up stateless algorithm depends on:<ul><li>The sending node&#x27;s queue size.</li><li>The rate of increase/decrease in queue size.</li><li>The processing time of the receiving node.</li></ul></li></ul><h4 id="streaming-flow">Streaming Flow:<a class="hash-link" href="#streaming-flow">#</a></h4><ul><li>The flow represents the movement of data through the pipeline nodes. It must start with a Stateful Node/Algorithm.</li><li>You can define more than one flow in every pipeline, and each flow has its unique name.</li><li><p>Streaming flows are defined using a simple syntax: &gt;&gt; is used for defining a streaming node flow, &amp; for &quot;and,&quot; and | for different streaming flows. Examples:</p><ul><li><p>Flow named &quot;flow1&quot; streams from node A to nodes B and C, and node B streams to node D. Syntax: A &gt;&gt; B&amp;C | B &gt;&gt; D.</p><pre class="prism language-json"><span class="punctuation">{</span>
<span class="attr-name">&quot;streaming&quot;</span><span class="punctuation">:</span> <span class="punctuation">{</span>
  <span class="attr-name">&quot;flows&quot;</span><span class="punctuation">:</span> <span class="punctuation">{</span>
      <span class="attr-name">&quot;flow1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A &gt;&gt; B&amp;C | B &gt;&gt; D&quot;</span><span class="punctuation">,</span>
  <span class="punctuation">}</span><span class="punctuation">,</span>
  <span class="attr-name">&quot;defaultFlow&quot;</span><span class="punctuation">:</span> <span class="string">&quot;master&quot;</span>
<span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p><img src="../../img/streaming/StreamingFlowExample1.png" alt="StreamFlowExample1"/></p></li><li><p>Flow named &quot;analyze&quot; streams from node &quot;sort&quot; to node A. Syntax: sort &gt;&gt; A.
Also, flow named &quot;master&quot; streams from node &quot;twitt&quot; to node &quot;sort,&quot; which then streams to node B. Syntax: twitt &gt;&gt; sort &gt;&gt; B.</p><pre class="prism language-json"><span class="punctuation">{</span>
<span class="attr-name">&quot;streaming&quot;</span><span class="punctuation">:</span> <span class="punctuation">{</span>
  <span class="attr-name">&quot;flows&quot;</span><span class="punctuation">:</span> <span class="punctuation">{</span>
      <span class="attr-name">&quot;analyze&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sort&gt;&gt;A&quot;</span><span class="punctuation">,</span>
      <span class="attr-name">&quot;master&quot;</span><span class="punctuation">:</span> <span class="string">&quot;twitt &gt;&gt;sort&gt;&gt;B&quot;</span>
  <span class="punctuation">}</span><span class="punctuation">,</span>
  <span class="attr-name">&quot;defaultFlow&quot;</span><span class="punctuation">:</span> <span class="string">&quot;master&quot;</span>
<span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p><img src="../../img/streaming/StreamingFlowExample2.png" alt="StreamFlowExample2"/></p></li></ul></li></ul><hr/><h3 id="streaming-algorithm-priority">Streaming Algorithm Priority<a class="hash-link" href="#streaming-algorithm-priority">#</a></h3><p>If you are experiencing slower algorithm allocation in streaming pipelines, these algorithms have a special priority setting. To use it, you need to set the <code>stateType</code> in your algorithm spec to either <strong>stateless</strong> or <strong>stateful</strong>.</p><p>When set:<br/>- <strong>Stateful</strong> - A Kubernetes Job is created and launched immediately. These jobs are given the highest priority and start execution right away.<br/>- <strong>Stateless</strong> - Jobs are launched after all stateful ones.  </p><p>Example for algorithm spec:</p><pre class="prism language-json"><span class="punctuation">{</span>
    <span class="attr-name">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stateful-alg&quot;</span><span class="punctuation">,</span>
    <span class="attr-name">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span>
    <span class="attr-name">&quot;gpu&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>
    <span class="attr-name">&quot;mem&quot;</span><span class="punctuation">:</span> <span class="string">&quot;256Mi&quot;</span><span class="punctuation">,</span>
    <span class="attr-name">&quot;stateType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stateful&quot;</span><span class="punctuation">,</span>
    <span class="attr-name">&quot;algorithmImage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hkube/algorithm-example-python&quot;</span>
<span class="punctuation">}</span></pre><hr/><h3 id="advanced">Advanced<a class="hash-link" href="#advanced">#</a></h3><h4 id="hkube-api-streaming-methods-for-stateful-algorithm">HKUBE API STREAMING METHODS for Stateful Algorithm<a class="hash-link" href="#hkube-api-streaming-methods-for-stateful-algorithm">#</a></h4><ul><li><strong>sendMessage(msg, flowName)</strong><ul><li>This method passes on a message to the next node in the pipeline flow.</li><li>Parameters:<ul><li>msg: A created message as desired to be obtained by the next node.</li><li>flowName: The name of the flow of nodes defined in the pipeline definition. This parameter should be given only if a new flow is initiated (not if the processing is already in the middle of a flow). If no flow name is given and the node is not in the middle of a flow initiated earlier, the default flow defined in the pipeline definition will be used as a flow name.</li></ul></li></ul></li><li><p><strong>registerInputListener(onMessage=handleMessage)</strong></p><ul><li>This method is used only within a stateful algorithm. It allows registering a method written by the algorithm implementor, which will be invoked upon each message that arrives.</li><li>The onMessage signature is onMessage(msg, origin), where the origin is the name of the previous node.</li></ul></li><li><p><strong>startMessageListening()</strong></p><ul><li>This method is used only within a stateful algorithm. Once all message handlers have been registered using registerInputListener, startMessageListening needs to be invoked to start receiving messages upon arrival.</li></ul></li></ul></div><div><a class="read-next" href="/learn/sidecars/"><span class="read-next-continue">Next →</span><span class="read-next-title">Sidecars</span></a></div></div><div class="nav-docs"><div><h3>Learn</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/debug/">Debug Algorithm</a><ul><li><a href="/learn/debug/#introduction">Introduction</a></li><li><a href="/learn/debug/#use-cases"> Use Cases</a></li><li><a href="/learn/debug/#how-to"> How To</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/pipelines/">Pipelines</a><ul><li><a href="/learn/pipelines/#raw">Raw</a></li><li><a href="/learn/pipelines/#stored"> Stored</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/nodes/">Nodes</a><ul><li><a href="/learn/nodes/#entry-nodes">Entry Nodes</a></li><li><a href="/learn/nodes/#final-nodes"> Final Nodes</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/input/">Input</a><ul><li><a href="/learn/input/#input-types">Input Types</a></li><li><a href="/learn/input/#input-order"> Input Order</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/options/">Options</a><ul><li><a href="/learn/options/#batch-tolerance">Batch Tolerance</a></li><li><a href="/learn/options/#verbosity-level"> Verbosity Level</a></li><li><a href="/learn/options/#pipeline-concurrency"> Pipeline Concurrency</a></li><li><a href="/learn/options/#ttl"> TTL</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/execution/">Pipeline Execution</a><ul><li><a href="/learn/execution/#flow-input">Flow Input</a></li><li><a href="/learn/execution/#reference"> Reference</a></li><li><a href="/learn/execution/#batch"> Batch</a></li><li><a href="/learn/execution/#batch-reference"> Batch Reference</a></li><li><a href="/learn/execution/#wait-any"> Wait Any</a></li><li><a href="/learn/execution/#output"> Output</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/advancedPipeline/">Advanced Pipeline Descriptor</a><ul><li><a href="/learn/advancedPipeline/#advance-options">Advance Options</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/triggers/">Triggers</a><ul><li><a href="/learn/triggers/#cron">Cron</a></li><li><a href="/learn/triggers/#pipelines"> Pipelines</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/webhooks/">Webhooks</a><ul><li><a href="/learn/webhooks/#progress">Progress</a></li><li><a href="/learn/webhooks/#result"> Result</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/caching/">Caching / Run Node</a><ul><li><a href="/learn/caching/#introduction">Introduction</a></li><li><a href="/learn/caching/#use-cases"> Use Cases</a></li><li><a href="/learn/caching/#how-to-activate-cache"> How to activate cache</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/codeapi/">Code API</a><ul><li><a href="/learn/codeapi/#introduction">Introduction</a></li><li><a href="/learn/codeapi/#python"> Python</a></li><li><a href="/learn/codeapi/#java"> Java</a></li><li><a href="/learn/codeapi/#node-js"> Node.js</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/versions/">Versions</a><ul><li><a href="/learn/versions/#algorithms">Algorithms</a></li><li><a href="/learn/versions/#pipelines"> Pipelines</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/tensorboard/">Tensorboard Integration</a><ul><li><a href="/learn/tensorboard/#introduction">Introduction</a></li><li><a href="/learn/tensorboard/#config"> Config</a></li></ul></li></ul></div></div></div></section><footer><section class="sitemap"><div class="sitemap-group"><h5><a href="/learn/">Learn</a></h5><a href="/learn/">Introduction</a><a href="/learn/pipelines/">Pipeline</a><a href="/learn/nodes/">Nodes</a><a href="/learn/input/">Input</a><a href="/learn/execution/">Execution</a><a href="/learn/webhooks/">Webhooks</a></div><div class="sitemap-group"><h5><a href="/tech/dashboard/">Dashboard</a></h5><a href="/tech/dashboard/#overview">Overview</a><a href="/tech/dashboard/#tables">Tables</a><a href="/tech/dashboard/#operations">Operations</a></div><div class="sitemap-group"><h5><a href="/media/">Media</a></h5><a href="/media/#jane/">Meet Jane</a><a href="/media/#distributed/">Distributed pipeline</a><a href="/media/#hpc/">HPC over Kubernetes</a><a href="/media/#architecture/">Hkube Architecture</a></div><div class="sitemap-group"><h5><a href="/learn/algorithms/">Algorithms</a></h5><a href="/learn/algorithms/">Introduction</a><a href="/learn/algorithms/#api/">API</a><a href="/learn/algorithms/#implement/">Implement</a><a href="/learn/algorithms/#build/">Build</a><a href="/learn/algorithms/#publish/">Publish</a></div></section><section class="copyright">Copyright ©<span><script>document.write(new Date().getFullYear())</script> </span><noscript>2018</noscript>Hkube. MIT</section></footer><script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script><script type="text/javascript" src="/vendor/scroller.js"></script><script>
        docsearch({
          appId: 'BQD9PBVIWN',
          apiKey: '1866dee8e47cc3f926114008ed8f7756',
          indexName: 'hkube',
          inputSelector: '#algolia-search-input',
          debug: false
        });
      </script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-118778729-1"></script><script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'UA-118778729-1');
      </script></body></html>